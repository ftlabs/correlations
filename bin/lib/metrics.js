// Include the 'net' module that manages a network connections
const fetchContent = require('./fetchContent');
const net = require('net');
const correlate = require('./correlate');


// Assign the values of the environment variable to constants for later use
const GRAPHITE_SERVER_URL = process.env.GRAPHITE_SERVER_URL;
const GRAPHITE_PORT = process.env.GRAPHITE_PORT;
const METRIC_PREFIX = process.env.METRIC_PREFIX;









// This function sends the metrics generated by the summariseFetchTimings function from the fetchContent script
function send_metrics() {

	// Create a connection to the graphite server. This connection is never closed as metrics are sent regularly
	var socket = net.createConnection(GRAPHITE_PORT, GRAPHITE_SERVER_URL, function() {
	});


	const data=fetchContent.summariseFetchTimings();
	// Assign the content of the POST object to the postObj object  
	const postObj1 = data["POST"];	
	// Get the list of all the keys fo the postObj
	const keys1 = Object.keys(postObj1);
	// Remove from postObj the property with the key statusesNotOk because this property is an arry
	const filtered1 = keys1.filter(key => {return key!="statusesNotOk"});


	// Assign the content of the GET object to the postObj object  
	const postObj2 = data["GET"];	
	// Get the list of all the keys fo the postObj
	const keys2 = Object.keys(postObj2);
	// Remove from postObj the property with the key statusesNotOk because this property is an arry
	const filtered2 = keys2.filter(key => {return key!="statusesNotOk"});


	const data2=correlate.summary();
	// Assign the content of the "counts" object to the postObj object  
	const postObj3 = data2["counts"];
	// Get the list of all the keys fo the postObj
	counts_items = Object.keys(postObj3);	
	// Get the value of the intervalCoveredHrs
	const intervalHrs = data2["times"]["intervalCoveredHrs"];




	/* 
		The format of the metrics that graphite understand is the following
			- Name of the metric:  It usually is a dot separated item: e.g. ft-lab.correlations-service
			- Metric:  It is a float number. You can use the parseFloat command to convert and integer to a float number
			- Timestamp:  Epoc formatted, 10 digits long timestamp. By default NodeJS generates longer epoch timestamps. 
			  You can use Math.floor(Date.now() / 1000) to generate a timestamp with the correct length 	


		Create the metrics to send to graphite. Then concatenate all the metrics into a single line. This will make sure that all the metrics are sent at the same time.
	*/


	//POST Metrics
	var metric_line1 = "";

	for(var i=0; i < filtered1.length; i++) {
		metric_line1 = metric_line1 + METRIC_PREFIX + correlate.ontology() + ".post." + filtered1[i] + " " + parseFloat(postObj1[filtered1[i]]) + " " + Math.floor(Date.now() / 1000) + "\n";
	}


	//GET Metrics
	var metric_line2 = "";

	for(var i=0; i < filtered2.length; i++) {
		metric_line2 = metric_line2 + METRIC_PREFIX + correlate.ontology() + ".get." + filtered2[i] + " " + parseFloat(postObj2[filtered2[i]]) + " " + Math.floor(Date.now() / 1000) + "\n";
	}


	//Summary Metrics
	var interval_metric = METRIC_PREFIX	+ correlate.ontology() + ".times.intervalCoveredHrs " + parseFloat(intervalHrs) + " " + Math.floor(Date.now() / 1000) + "\n";
	var metric_line3 = interval_metric;

	for( i in counts_items) {
		metric_line3 = metric_line3 + METRIC_PREFIX + correlate.ontology() + ".counts." + counts_items[i] + " " + parseFloat(postObj3[counts_items[i]]) + " " + Math.floor(Date.now() / 1000) + "\n";
	}




	// Group all the metrics
	metrics_to_send = metric_line1 + metric_line2 + metric_line3


	// Send the metric to the graphite server
	const writeResponse = socket.write(metrics_to_send, function () {
		});


	// Closing the connection to the graphite server
	socket.end();
}






// Export the functions created in this file
module.exports = {
	send_metrics,

};

