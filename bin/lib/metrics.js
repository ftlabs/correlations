// Include the 'net' module that manages a network connections
const fetchContent = require('./fetchContent');
const net = require('net');
const correlate = require('./correlate');


// Assign the values of the environment variable to constants for later use
const GRAPHITE_SERVER_URL = process.env.GRAPHITE_SERVER_URL;
const GRAPHITE_PORT = process.env.GRAPHITE_PORT;
const METRIC_PREFIX = process.env.METRIC_PREFIX;


// Create a connection to the graphite server. This connection is never closed as metrics are sent regularly
var socket = net.createConnection(GRAPHITE_PORT, GRAPHITE_SERVER_URL, function() {
});






// This function sends the metrics generated by the summariseFetchTimings function from the fetchContent script
function send_post_metrics() {

	const data=fetchContent.summariseFetchTimings();
	// Assign the content of the POST object to the postObj object  
	const postObj = data["POST"];	
	// Get the list of all the keys fo the postObj
	const keys = Object.keys(postObj);
	// Remove from postObj the property with the key statusesNotOk because this property is an arry
	const filtered = keys.filter(key => {return key!="statusesNotOk"});

	/*
		Create the metrics to send to graphite. Then concatenate all the metrics into a single line. This will make sure that all the metrics are sent at the same time.
	*/
	var metric_line = "";

	for(var i=0; i < filtered.length; i++) {
		metric_line = metric_line + METRIC_PREFIX + correlate.ontology() + ".post." + filtered[i] + " " + parseFloat(postObj[filtered[i]]) + " " + Math.floor(Date.now() / 1000) + "\n";
	}

	// Send the metric to the graphite server
	const writeResponse = socket.write(metric_line, function () {
		});
}






// This function sends the metrics generated by the summariseFetchTimings function from the fetchContent script
function send_get_metrics() {

	const data=fetchContent.summariseFetchTimings();
	// Assign the content of the GET object to the postObj object  
	const postObj = data["GET"];	
	// Get the list of all the keys fo the postObj
	const keys = Object.keys(postObj);
	// Remove from postObj the property with the key statusesNotOk because this property is an arry
	const filtered = keys.filter(key => {return key!="statusesNotOk"});


	/*
		Create the metrics to send to graphite. Then concatenate all the metrics into a single line. This will make sure that all the metrics are sent at the same time.
	*/
	var metric_line = "";

	for(var i=0; i < filtered.length; i++) {
		metric_line = metric_line + METRIC_PREFIX + correlate.ontology() + ".get." + filtered[i] + " " + parseFloat(postObj[filtered[i]]) + " " + Math.floor(Date.now() / 1000) + "\n";
	}

	// Send the metric to the graphite server
	const writeResponse = socket.write(metric_line, function () {
		});
}






// This function sends the metrics generated by the summary function from the correlate script
function send_summary_metrics() {

	const data=correlate.summary();
	// Assign the content of the "counts" object to the postObj object  
	const postObj = data["counts"];
	// Get the list of all the keys fo the postObj
	counts_items = Object.keys(postObj);	
	// Get the value of the intervalCoveredHrs
	const intervalHrs = data["times"]["intervalCoveredHrs"];
	

	/*
		Create the metrics to send to graphite. Then concatenate all the metrics into a single line. This will make sure that all the metrics are sent at the same time.
	*/
	var interval_metric = METRIC_PREFIX	+ correlate.ontology() + ".times.intervalCoveredHrs " + parseFloat(intervalHrs) + " " + Math.floor(Date.now() / 1000) + "\n";
	var metric_line = interval_metric;

	for( i in counts_items) {
		metric_line = metric_line + METRIC_PREFIX + correlate.ontology() + ".counts." + counts_items[i] + " " + parseFloat(postObj[counts_items[i]]) + " " + Math.floor(Date.now() / 1000) + "\n";
	}

	// Send the metric to the graphite server
	const writeResponse = socket.write(metric_line, function () {
	});	
}






// Export the functions created in this file
module.exports = {
	send_get_metrics,
	send_post_metrics,
	send_summary_metrics,
};

